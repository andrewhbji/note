[TOC]

# 依赖关系

- 依赖 appbase.
- 依赖txpushlib接入Push,
- 依赖indexbar用于实现通讯录安字母快速检索
- 依赖materialcalendarview用于实现领导工作安排的时间选择器

# 资源说明
- color 使用xml生成UI组件配色
- drawable  使用xml生成ui组件
- drawable-*dpi 图片,点九图资源文件
- layout 布局文件
- menu 菜单描述
- raw.bootstrap_data.json 预加载数据
- values.colors 配置颜色值常量
- values.dimens 配置UI尺寸
- values.strings* 配置string常量
- values.style 样式文件
- values-* 其他分辨率下使用的资源文件
- xml.about_preference 关于界面显示内容
- xml.authenicator 配置系统账户框架
- xml.adapter 配置系统同步框架框架
- xml.seachable 配置系统搜索框架

# 源码说明

## app

- *.app.App: 系统Application类的子类,初始化Push接口和异步通信框架volley

## appbase

- *.base.AbstractBaseActivity: UI框架
- *.base.BaseActivityImpl: 继承AbstractBaseActivity,实现:

	- 填充主界面侧滑菜单icon 文本
	- 填充当前活动帐号信息
	- 主菜单点击事件
	- 登录逻辑
	- 预加载数据

- *.base.HttpRequest: 用于Volley框架的通用HttpRequest对象
- *.base.RecentTaskStyler: 生成任务管理器内的样式
- *.base.LoginAndAuthHelper: 授权Helper，实现授权，注册推送服务逻辑
- *.base.Callback： LoginAndAuthHelper的回调接口，在BaseActivityImpl中使用
- *.base.AppDataHandler: 将各个业务中io包下的类配置在这里，在其中统一调用JSONHandler.process和JSONHandler.makeContentProviderOperations 解析JSON并对数据进行CUD操作

## 通讯录

### 代码说明

- *.contacts 通讯录业务代码
	- *.contacts.io 更新数据库
		- *.io.ContactsHandler 更新Contact数据库
		- *.io.ContactTypeHandler 更新ContactsType数据库
	- *.model dao类
		- *.model.Contact: Contact 数据
		- *.model.ContactType: ContactType数据
		- *.model.ContactTypeMetaData: 从ContactsType数据库获取数据,排序并重新封装成MetaData,用于生成通讯录类型下拉切换组件
	- *.ui UI类
		- *.ui.BrowseContactsActivity: 通讯录列表的父容器,快速索引组件,以及通讯录切换组件
		- *.ui.ContactsFragment: 通讯录列表
		- *.ui.ContactDetailActivity: 通讯录详情
		- *.ui.SearchActivity: 匹配查询界面 目前实现了姓名,电话匹配查询

### 数据加载逻辑
1. BrowseContactsActivity: 初始化ContactsFragment,先给一个空的intent，由ContactsFragments生成默认的查询url
	
	```java
	    @Override
	    protected void onPostCreate(Bundle savedInstanceState) {
	        super.onPostCreate(savedInstanceState);
	        mContactsFragment = (ContactsFragment) 	getSupportFragmentManager().findFragmentById(R.id.contacts_fragment);
	        // 初始化mContactsFragment时先给一个空的intent，由mContactsFragments生成默认的查询url
	        if (mContactsFragment != null && savedInstanceState == null) {
	            Bundle args = intentToFragmentArguments(getIntent());
	            mContactsFragment.reloadFromArguments(args);
	        }
	    }
	```
	
2. ContactsFragment: 根据reloadFromArguments(Bundle args)传递的参数生成URL,然后根据URL从数据库查询通讯录,同时查询ContactTypeMataData
	
	```java
	    void reloadFromArguments(Bundle args) {
	        if (args == null) {
	            args = new Bundle();
	        } else {
	            args = (Bundle) args.clone();
	        }
	        mArguments = args;
	        Log.i(TAG, "BrowseContactsFragment reload from arguments: " + mArguments);

	        mCurrentUri = mArguments.getParcelable("_uri");
	        if (mCurrentUri == null) {
	            //如果uri为空，默认为单位通讯录URI
	            Log.i(TAG, "BrowseContactsFragment did not get a URL, default to TYPE_DWTXL");
	            String[] mFilterTags = {Config.ContactsTypes.CATEGORY_DWTXL, "", ""};
	            args = AbstractBaseActivity.intentToFragmentArguments(
                    new Intent(Intent.ACTION_VIEW, Contract.Contacts.buildTypeFilterUri(mFilterTags)));
	            reloadFromArguments(args);
	        }
	        mNoTrackBranding = mArguments.getBoolean(EXTRA_NO_TRACK_BRANDING);
	        if (Contract.Contacts.isSearchUri(mCurrentUri)) {
	            mContactQueryToken = ContactsQuery.SEARCH_TOKEN;
	        } else {
	            mContactQueryToken = ContactsQuery.NORMAL_TOKEN;
	        }
	        Log.d(TAG, "ContactsFragment reloading, uri=" + mCurrentUri);
	        reloadContactData(true);
	        if (mContactTypeMetadata == null) {
	            reloadTagMetadata();
	        }
	    }
	```

3. ContactsFragment: 将查询出来的contact数据填充进CollectionView,将ContactTypeMataData通过Callbacks.onTagMetadataLoaded传回给BrowseContactsActivity

	```java
	    @Override
	    public void onLoadFinished(Loader<Cursor> loader, Cursor cursor) {
	        int token = loader.getId();
	        if (token == ContactsQuery.NORMAL_TOKEN || token == ContactsQuery.SEARCH_TOKEN) {
	            if (mCursor != null && mCursor != cursor) {
	                mCursor.close();
	            }
	            mCursor = cursor;
	            mIsSearchCursor = token == ContactsQuery.SEARCH_TOKEN;
	            Log.d(TAG, "Cursor has " + mCursor.getCount() + " items. Will now update list view.");
	            updateCollectionView(token);
	        } else if (token == TAG_METADATA_TOKEN) {
	            mContactTypeMetadata = new ContactTypeMetadata(cursor);
	            cursor.close();
	            updateCollectionView(token);
	            mCallbacks.onTagMetadataLoaded(mContactTypeMetadata);
	        }
	    }
	```

4.  BrowseContactsActivity:

	- 通讯录切换组件使用Spinner + SpinnerAdapter实现

		- ContactTypeMetadata在通讯录内容加载完毕后由ContentsFragment生成并传递给Activity,Activity在onTagMetadataLoaded()回调中调用trySetUpActionBarSpinner()将metadata填充进入SpinnerAdapter,并设置Spinner样式和点击动作,代码如下:
		
			```java
				mSpinnerAdapter.clear();

		        mSpinnerAdapter.addItem("", "单位通讯录", false, "");

		        int itemToSelect = -1;
		        if (mTypeMetadata.getTypeList().size() != 0) {
		            mSpinnerAdapter.clear();
		            for (ContactTypeMetadata.Type type : mTypeMetadata.getTypeList()) {
		                Log.d(TAG, "Adding item to spinner: " + type.getID() + " --> " + type.getName());
			             mSpinnerAdapter.addItem(type.getID(), type.getName(), true, type.getColor());
			             if (!TextUtils.isEmpty(mFilterTagsToRestore[0]) && type.getID().equals(mFilterTagsToRestore[0])) {
					        mFilterTagsToRestore[0] = null;
                    itemToSelect = mSpinnerAdapter.getCount() - 1;
			             }
		            }
		        }
			```
						
			```java
				View spinnerContainer = LayoutInflater.from(this).inflate(R.layout.actionbar_spinner,
                toolbar, false);
		        ActionBar.LayoutParams lp = new ActionBar.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
		        toolbar.addView(spinnerContainer, lp);
		        Spinner spinner = (Spinner) spinnerContainer.findViewById(R.id.actionbar_spinner);
		        spinner.setAdapter(mSpinnerAdapter);
		        spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
		            @Override
		            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
		                onTopLevelTagSelected(mSpinnerAdapter.getTag(position));
		            }

		            @Override
		            public void onNothingSelected(AdapterView<?> parent) {
		
	            }
        });		
			```
			
		- SpinnerAdapter继承自BaseAdapter,实现绑定数据,生成view(默认和下拉状态),以及是否可点击.

	- 快速索引组件使用indexbar实现,代码如下:
	
		- 字母为#,A,B,C....Z 在  mIndexBar.setSections(alphabets()) 中填充
		
		- Filter数据在通讯录内容加载完毕后由ContentsFragment生成并传递给Activity,Activity在onUpdateInventory()回调中将数据装入FilterList
		
			```java
			    @Override
			    public void onUpdateInventory(final Map<String, Integer> sections) {
			        mIndexBar.setSections(alphabets());
			        mIndexBar.setIndexBarFilter(new IndexBar.IIndexBarFilter() {
				         @Override
			            public void filterList(float sideIndex, int position, String previewText) {
		                Integer selection = sections.get(previewText);
			            if (selection != null) {
		                    mPreviewText.setVisibility(View.VISIBLE);
		                    mPreviewText.setText(previewText);
		                    mContactsFragment.setSelection(selection);
		                } else {
		                    mPreviewText.setVisibility(View.GONE);
		                }
		            }
		        });
		    }
			```

## 领导工作安排

### 代码说明

- *.jobs 领导工作安排业务代码
	- *.io 更新数据库
		- *.io.JobsHandler 更新Jobs数据库
	- *.model model类
		- *.model.Job: Job 数据
	- *.ui UI类
		- *.ui.BrowseJobsActivity: 工作列表、时间选择器
		- *.ui.JobEditorActivity: 工作详情编辑界面
		- *.ui.SimpleListView: 工作列表，使用LinearLayout 实现

- *.login 领导工作安排业务代码
	- *.model model类
		- *.model.LoginModel: 登录数据 
	- *LoginAction: 调用NetConnection实现登录方法
	- *LoginActivity: 登录界面

### 数据加载逻辑

## Push

- *.observer: 观察者接口,用于接入push
- *.push.PushReceiver: 接收Push消息广播
- *.push.SetDeleteTagReceiver: 接收设置/删除Tag广播

## ContentProvider

- *.provider.Contract: 数据库字段,以及数据表URL
- *.provider.Database: 继承Android 系统SQLiteHelper,实现数据库初始化逻辑
- *.provider.Provider: 继承Android ContentProvider, 封装数据CURD

## 闪屏
- *.SplashScreenActivity: 闪屏界面

## 同步
- *.sync 后台同步Server
	- *.sync.SyncAdapter: 继承AbstractThreadedSyncAdapter,被系统调度
	- *.sync.SyncService: sync必须的服务类，由系统调用创建服务，然后通过这个Server调用SyncAdapter
	- *.sync.SyncHelper: 实现同步业务
	- *.sync.SyncDataFetcher: 获取数据的工具，在Service线程中执行