[TOC]
#特殊字符
## \#
注释
###注意事项
- 注释也可以出现在一行开头的一系列空白符(whitespace)之后
```sh
    # 这个注释前面存在一个制表符(tab)
```
- 注释可以出现在管道中
```sh
initial=( `cat "$startfile" | sed -e '/#/d' | tr -d '\n' |\
# 删除所有带'#'注释符号的行
           sed -e 's/\./\. /g' -e 's/_/_ /g'` )
# 摘录自脚本 life.sh
```
- echo语句中出现的#或者被转义的#不会被认为是注释
```sh
echo "The # here does not begin a comment."
echo 'The # here does not begin a comment.'
echo The \# here does not begin a comment.
echo ${PATH#*:}       # 参数代换而非注释
echo $(( 2#101011 ))  # 进制转换而非注释
```
## ;
命令分隔符，允许在同一行内放两条或更多命令
```sh
echo "File $filename exists."; cp $filename $filename.bak
```
## ;;
case 条件语句终止符
## ;;&, ;&
case  条件语句终止符(需Bash 4版本及以上)。
## .
- 句点命令，等价于source
```sh
. data-file # 加载一个数据文件，与"source data-file"效果相同, 但是更具可移植性.
```
- 文件/路径名的一部分(隐藏文件的文件名前缀,当前路径的别名)
- 通配符，意味匹配任意一个字母
## "
部分引用[双引号]。在字符串中保留大部分的特殊字符。
## '
全引用[单引号]。在字符串中保留所有的特殊字符。是部分引用的强化版。
## ,
- 逗号运算符,将一系列的算术表达式串联在一起。所有的算术表达式都会被执行,但只有最后一个被计算的表达式的值将会被返回。
```sh
let "t2 = ((a = 9, 15 / 3))"
# 设定 "a = 9" 与 "t2 = 15 / 3"
```
- 字符串连接符
```sh
for file in /{,usr/}bin/*calc
#             ^    在 /bin 与 /usr/bin 目录中
#+                找到所有的以"calc"结尾的可执行文件
do
        if [ -x "$file" ]
        then
          echo $file
        fi
done
# /bin/ipcalc
# /usr/bin/kcalc
# /usr/bin/oidcalc
# /usr/bin/oocalc
```
## ”'
在参数代换中进行小写字母转换(Bash 4中新增)。
## \\
转义符
## /
- 文件路径分隔符
- 除法运算符
## `
命令替换符。  `command`   结构可以使得命令的输出结果赋值给一个变量
## :
- 空命令[冒号]。它在shell中等价于"NOP"(即no op,空操作)
```sh
:
echo $?   # 0
```
- 是Bash的内建命令,返回值是true
```sh
while :
do
   operation-1
   operation-2
   ...
   operation-n
done
# 等价于
#    while true
#    do
#      ...
#    done
```
- if语句中的占位符
```sh
if condition
then :   # 什么都不做,只是建立一个分支
else
   take-some-action
fi
```
- 二元操作的占位符
```sh
: ${username=`whoami`}
# ${username=`whoami`}   如果没有:就会报错，除非 "username" 是一个命令或内建命令
: ${1?"Usage: $0 ARGUMENT"}     # 摘自样例脚本 "usage-message.sh"
```
- 参数替换占位符
```sh
: ${HOSTNAME?} ${USER?} ${MAIL?}
#  如果其中一个或多个必要的环境变量没有被设置
#+ 那么将会打印错误
```
- 变量扩展/字串替换占位符
```sh
${var:pos}
# 变量 var 从位置 pos 开始扩展( 也就是pos之前的字符都丢弃).
```
- 与 > 重定向操作符结合,可以在不改变权限的情况下清空文件。如果文件不存
在,那么将会创建这个文件。
```sh
: > data.xxx   # 文件 "data.xxx" 已经被清空
# 与 cat /dev/null >data.xxx 作用相同
# 但是这个操作并不会产生一个新的进程,因为 ":" 是一个内建命令。
```
- 与 >> 重定向操作符结合将不会清空任何已经存在的文件(: >>target_file  )
- 一行注释的开头
它也可以用来作为一行注释的开头,尽管我们并不推荐这么做。使用 # 可以使解释器对这一行不进行错误检测,所以几乎所有都可以出现在注释中。但是下面的情况却不是这样的:
```
: 这一行注释将会产生一个错误,( if [ $x -eq 3] )
```
- 作为一个域的分隔符，比如环境变量
```sh
$ echo $PATH
/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games
```
- 作为函数名称，但是不推荐使用，最新版本的bash已经禁用这种用法，
```sh
:()
{
  echo "The name of this function is "$FUNCNAME" "
  # 为什么要使用冒号作为函数名称?
  # 这是一种混淆代码的方式。
}
:
# 函数名称是 :
```
- 非空函数的占位符
```sh
not_empty ()
{
  :
} # 含有空指令,因此这并不是一个空函数。
```
## !
反转测试操作符(如 = )或者函数/脚本调用的返回状态
## *
- 通配符，代表任意n个字符
- 乘法运算符
## ?
- 条件测试操作符，如三元运算中的？
- 通配符，代表任意一个字符
## $
- 用来引用变量
- 行结束符
## ${}
参数替换
## $'...'
引用字符串
## \$\*,$@
位置参数
## $?
返回状态变量
## $$
进程ID变量
## ()
- 命令组
```sh
(a=hello; echo $a)
```
- 数组初始化
```sh
Array=(element1 element2 element3)
```
## {xxx,yyy,zzz,...}
大括号扩展结构
## {}
- 代码块，实质为匿名函数，但是代码快内的变量在代码快外部依旧可见
- 文本占位符，在xargs -i 后作为输出的占位符来使用
## {}\\;
路径名。通常在   find   命令中使用,但这不是shell的内建命令。
## []
- 测试，在[]之间填写测试表达式
- 数组元素
## [[]]
测试，在[[]]之间填写测试表达式
## $[ ... ]
整数扩展符。在 $[ ] 中可以计算整数的算术表达式。
## (( ))
整数扩展符。在 (( )) 中可以计算整数的算术表达式
## > &> >& >> < <>
重定向
## <<
在here document中进行重定向
## <<<
在here string中进行重定向
## <,>
ASCII码比较
## \\<,>
正则表达式中单词的边界
## |
管道
## >|
强制重定向
## ||
逻辑或运算
## &
后台运行操作符，如果命令后由&,将会使这个命令转至后台运行
## &&
逻辑与运算
## -
- 选项、前缀，在所有的命令内如果想使用选项参数的话,前边都要加上"-"
- 重定向输入输出
- 代表先前工作的目录
- 减法运算符
## --
长选项的前缀
## =
赋值操作符
## +
- 加法运算符
- 选项操作符
## %
- 模运算符
- 模式匹配操作符
## ~
代表home路径
## ~+
当前工作路径
## ~-
先前工作路径
## =~
正则表达式匹配
## ^
行起始符
## ^, ^^
参数替换中的大写转换符
## 控制符
### Ctl-A
在命令行中将光标移动到这一行文本的起始位置。
### Ctl-B
非破坏性退格(即不删除字符)。
### Ctl-C
中断。终止一个前台运行的任务。
### Ctl-D
登出shell(类似   exit  )
键入   EOF  (end-of-file,文件终止标记),中断来自 stdin 的输入。
当你在终端或 xterm 窗口中输入字符时,  Ctl-D   将会删除光标上的字符。当没有
字符时,  Crl-D   将会登出shell。在 xterm 中,将会关闭整个窗口。
### Ctl-E
在命令行中将光标移动到这一行文本的结束位置。
### Ctl-F
在命令行中将光标向前移动一个字符。
### Ctl-G
 BEL  。在一些老式的打字机终端上,将会响铃。而在 xterm 中,将会产生一
个“哔”声。
### Ctl-H
抹除(破坏性退格)。退格时删除前面的字符。
### Ctl-I
水平制表符。
### Ctl-J
另起一行(换行)。在脚本中,你也可使用八进制 '\012' 或者十六进制 '\x0a' 来表
示。
### Ctl-K
垂直制表符。
当你在终端或 xterm 窗口中输入字符时,  Ctl-K   将会删除光标上及其后的所有字
符。而在脚本中,  Ctl-K   的作用有些不同。具体查看下方 Lee Lee Maschmeyer
写的样例。
### Ctl-L
清屏、进纸。在终端中等同于   clear   命令。在打印时,  Ctl-L   将会使纸张移动
到底部。
### Ctl-M
回车(CR)。
### Ctl-N
在命令行历史缓存中调用下一条历史命令 8 。
### Ctl-O
在命令行中另起一行。
### Ctl-P
在命令行历史缓存中调用上一条历史命令。
### Ctl-Q
恢复(XON)。
在终端中恢复读入 stdin。
### Ctl-R
在命令行历史缓存中进行搜索。
### Ctl-S
挂起(XOFF)。
在终端中冻结 stdin。(可以使用   Ctl-Q   恢复)
### Ctl-T
在命令行中,交换光标所在字符与其前一个字符。
### Ctl-U
删除光标所在字符之前的所有字符。在一些情况下,不管光标在哪个位置,  Ctl-
U   都会删除整行文字。
### Ctl-V
在输入的时候,使用   Ctl-V   允许插入控制符。例如,下面两条语句是等价的:
```sh
echo -e '\x0a'
echo <Ctl-V><Ctl-J>
```
### Ctl-W
当你在终端或 xterm 窗口中输入字符时,  Ctl-W   将会删除光标所在字符之前到其
最近的空白符之间的所有字符。在一些情况下,  Ctl-W   将会删除到之前最近的非
字母或数字的字符。
### Ctl-X
在一些特定的文本处理程序中,它将会剪切高亮文本并复制到剪贴板(clipboard)
中。
### Ctl-Y
粘贴之前使用   Ctl-U   或   Ctl-W   删除的文字。
### Ctl-Z
暂停前台运行的任务。
在一些特定的文本处理程序中是替代操作。
在 MSDOS 文件系统中是作为   EOF  (end-of-file,文件终止标记)。
## 空白符
作为命令或变量之间的分隔符。空白符包含空格、制表符、空白或它们的任意组合
