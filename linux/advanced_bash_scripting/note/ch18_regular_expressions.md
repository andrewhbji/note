[TOC]
# 正则表达式
## 19.1 正则表达式介绍
正则表达式是一个字符串，其中字符被称为元字符，它们可能表示了比它们字面上看起来的意思更丰富的含义
### 正则表达式的组成
正则表达式是一个字符串，由字符集和元字符组成。正则表达式最简单的情况就是仅仅由字符集组成，没有元字符
#### 字符集
字符集里的字符就是其字面意思
#### 元字符
##### 锚
秒指明了正则表达式在一行文本中要匹配的位置，例如^和$
##### 修饰符
用于扩展或缩小(或者修改)正则表达式匹配的文本行的范围，修饰符包括 \*、\(\) 和 \\
### 正则表达式的作用
文本搜索和字串操作
#### 星号 -- * --
匹配前一个字符的任意多次(包括零次)
```
1133* # 匹配 11 + 一个或更多的 3+ 更多的其他字符，如：113,1133，111312等
```
#### 点 -- . --
匹配除了新行符之外的任意一个字符
```
13. # 匹配 13+ 至少一个任意字符(包括空格): 1133,11333，但不匹配 13(因为少了附加的至少一个任意字符)
```
>备注：因为sed，awk和grep通常处理单行，而不能匹配多个新行符，要在处理多行的一个输入时，可以使用点操作符，它可以匹配一个新的行符
```sh
$ sed -e 'N;s/.*/[&]/' << EOF
> line1 # ^ N 将两行当作一行处理
> line2 #     ^ 将匹配line1前面的换行符和line2后面的换行符
> EOF   #        ^ [&] 将匹配到的第n(n为偶数)+1个换行符替换为 [,将匹配到的第n(n为偶数)个换行符替换为 ]
# 输出
# [line1
# line2]
$ awk '{ $0=$1 "\n" $2; if (/line.1/) {print}}' << EOF
> line 1
> line 2
> EOF
# 输出
# line
# 1
```

#### 脱字符 -- ^ --
匹配一行的开头,但依赖于上下文环境,可能在正则表达式中表示否定一个字符集的意思
#### 美元符 -- $ --
匹配行尾
```
^$ # 匹配空行
```
#### 方括号 -- [...] --
匹配括号中的一个字符
```
[xyz] # 匹配字符 x, y, 或 z
[c-n] # 匹配从字符 c 到 n 之间的任意一个字符
[B-Pk-y] # 匹配从 B 到 P 或从 k 到 y 的任意一个字符
[a-z0-9] # 匹配任意小写字母或数字
[^b-d] # 匹配除了从 b 到 d 范围内所有的字符
```
> 备注：多个方括号字符集组合使用，可以匹配一般的单词或数字，如"[Yy][Ee][Ss]" 匹配 yes, Yes, YES, yEs, 等等;
"[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]"匹配身份证号

#### 转义符号 -- \\ --
使锚、修饰符等变为字符集
#### 转义尖括号 -- \\<...\\> --
表示单词的边界
```
\<the\> # 匹配单词 the ，不匹配"them", "there", "other",等等
```
### 确定正则表达式的方法
唯一的方法就是测试它
### 扩展正则表达式
增加了一些元字符
#### 问号 -- ？ --
匹配零个或一个前面得字符，一般用于匹配单个字符
#### 加号 -- + --
匹配一个或多个前面的字符，和*类似，但不匹配零个字符的情况
#### 转义大括号 -- \\{ \\} --
指定前面正则表达式匹配的次数
```
[0-9]\{5\} # 精确匹配 5 个数字
```
> gawk 的 -re-interview中直接使用不用转义的大括号来指定匹配的次数

#### 圆括号 -- ( ) --
一组正则表达式
#### 竖线 -- | --
正则表达式的逻辑或操作符，用于匹配一组字符
```sh
$ egrep 're(a|e)d' misc.txt # 输出misc.txt 文件中存在read和reed的行
```
### POSIX 字符
#### [:class:]
这是另外一个可选的用于指定匹配字符范围的方法
#### [:alnum:]
匹配字母和数字.等同于 A-Za-z0-9
#### [:alpha:]
匹配字母. 等同于 A-Za-z
#### [:blank:]
匹配一个空格或是一个制表符(tab)
#### [:cntrl:]
匹配控制字符
#### [:digit:]
匹配(十进制)数字. 等同于 0-9
#### [:graph:]
(可打印的图形字符). 匹配 ASCII 码值的 33 - 126 之间的字符. 这和下面提到的[:print:]一样,但是不包括空格字符.
#### [:lower:]
匹配小写字母. 等同于 a-z.
#### [:print:]
(可打印字符). 匹配 ASCII 码值 32 - 126 之间的字符. 这和上面提到的[:graph:]一样,但是增多一个空格字符
#### [:space:]
匹配空白字符 (空格符和水平制表符)
#### [:upper:]
匹配大写字母. 等同于 A-Z
#### [:xdigit:]
匹配十六进制数字. 等同于 0-9A-Fa-f
> 备注： POSIX兹弗雷一般都要求用引号或者双引号扩起来
```sh
$ grep [[:digit:]] test.file
abc=723
```
>这些字符类在一个受限的范围内甚至可能用在能用在通配(globbing)中
```sh
$ ls -l ?[[:digit:]][[:digit:]]?
-rw-rw-r--
1 bozo bozo
0 Aug 21 14:47 a33b
```

## 19.2 通配符
通配符不是标准的正则表达式，一般用于匹配文件名
### 通配符包括
#### *
匹配任意n个字符
#### ？
匹配任意一个字符
#### ^
对通配符表达式进行取反
#### []
子表达式
#### {}
一组通配符
```sh
$ ls -l
total 2
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt

$ ls -l t?.sh
-rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh

$ ls -l [ab]*
-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1

$ ls -l [a-c]*
-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1

$ ls -l [^ab]*
-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt

$ ls -l {b*,c*,*est*}
-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt
```
>备注：
>1. 文件名扩展意思是扩展包含有特殊字符的文件名模式和模板. 例如,example.???可能扩展成 example.001 和/或 example.txt
>2. set -f 命令会禁用使用通配符匹配文件，shopt的选项nocaseglob 和 nullglob 能改变通配的行为
>3. 文件名中嵌入空格符会引起无法用通配符匹配，使用IFS="$(printf '\n\t')"可以解决这个问题
>4. 匹配文件名时，进在通配符字串名切的包含某个字符的字面意思时(如点(.))，才能匹配
```sh
～/[.]bashrc # 不能匹配～/.bashrc
～/?bashrc # 不能匹配～/.bashrc
～/.[b]ashrc # 可以匹配～/.bashrc
～/.ba?hrc # 可以匹配～/.bashrc
～/.bashr* # 可以匹配～/.bashrc
```
